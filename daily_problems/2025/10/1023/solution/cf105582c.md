**提示 1：** 显然越多套越难凑。

**提示 2：** 如何检查某个套数。

首先，套数越多，每个品类的选择空间越少，也就越难达成。

因此本题可以二分。

考虑形成 $k$ 套，则第 $i$ 个物品可以用 $\lfloor c_i/k\rfloor$ 次。

接下来就是问这些物品能否凑出来 $[n_{min},n_{max}]$ 之间的数。这是简单的多重背包问题。

下面的实现比较干净，不需要滚动数组，只需在原 DP 数组中修改。大概是关于 $m_i$ 取模的不同结果分别考虑，遍历到第 $i$ 个下标时，记录下这个下标可达意味着的最大的可达下标，接下来只需判断是否不超过最大可达下标即可，这里用到了转移的连续性。

最后记得去掉空集，时间复杂度为 $\mathcal{O}(nM\log M')$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, mi, ma = MII()
    
    ms = []
    cs = []
    
    for _ in range(n):
        m, c = MII()
        ms.append(m)
        cs.append(c)
    
    M = 10 ** 4
    l, r = 1, 10 ** 6
    dp = [0] * (M + 1)
    
    while l <= r:
        mid = (l + r) // 2
        
        for i in range(M + 1):
            dp[i] = 0
        
        dp[0] = 1
        
        for i in range(n):
            m = ms[i]
            c = cs[i] // mid
            
            for j in range(m):
                bound = -1
                for x in range(j, M + 1, m):
                    if dp[x]:
                        bound = fmax(bound, x + c * m)
                    if x <= bound:
                        dp[x] = 1
        
        flg = False
        for i in range(mi, ma + 1):
            if dp[i]:
                flg = True
        
        if flg: l = mid + 1
        else: r = mid - 1
    
    print(r)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mi, ma;
	cin >> n >> mi >> ma;

	vector<pair<int, int>> items(n);
	for (auto &[x, y]: items) cin >> x >> y;

	int l = 1, r = 1e6, M = 1e4;

	while (l <= r) {
		int mid = (l + r) / 2;

		vector<int> dp(M + 1, 0);
		dp[0] = 1;

		for (auto &[x, y]: items) {
			int m = x, c = y / mid;

			for (int j = 0; j < m; j ++) {
				long long bound = -1;
				for (int x = j; x <= M; x += m) {
					if (dp[x]) bound = max(bound, x + 1ll * c * m);
					if (x <= bound) dp[x] = 1;
				}
			}
		}

		bool flg = false;
		for (int i = mi; i <= ma; i ++)
			if (dp[i]) flg = true;
		
		if (flg) l = mid + 1;
		else r = mid - 1;
	}

	cout << r;

	return 0;
}
```