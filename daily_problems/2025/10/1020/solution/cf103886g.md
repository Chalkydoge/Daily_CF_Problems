**提示 1：** 答案可能是什么形式？

**提示 2：** 其实备选不多。

答案的每个质因子的次数不需要大于 $1$ ，因为如果次数 $\geq 2$ 成立的话，等于 $1$ 也仍然不互质。

所以答案一定是一系列质数的乘积。而 $1\sim 50$ 范围内只有 $15$ 个质数（也是本题标题），所以直接枚举 $2^15$ 种答案就行。

判断的过程中不需要完整遍历数组，只需看 $1\sim 50$ 的数哪些出现过，哪些没出现，考虑那些出现过的数和备选答案的最大公约数即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def solve(x):
        if x == 1: return [1]
        even = x // 2
        odd = x - x // 2
        return [x * 2 for x in solve(even)] + [x * 2 - 1 for x in solve(odd)]
    
    n = II()
    print(*solve(n))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	vector<int> prs = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
	vector<long long> to_check = {1};

	for (auto &x: prs) {
		int k = to_check.size();
		for (int i = 0; i < k; i ++) {
			to_check.emplace_back(to_check[i] * x);
		}
	}

	sort(to_check.begin(), to_check.end());

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> vis(51, 0);
		while (n --) {
			int x;
			cin >> x;
			vis[x] = 1;
		}

		for (auto &v: to_check) {
			bool flg = true;
			for (int i = 0; i <= 50; i ++) {
				if (vis[i] && gcd(i, v) == 1) {
					flg = false;
					break;
				}
			}
			if (flg) {
				cout << v << '\n';
				break;
			}
		}
	}

	return 0;
}
```