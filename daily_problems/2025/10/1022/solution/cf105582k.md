**提示 1：** 先不管不平行于坐标轴的条件，构造一个简单的图形。

**提示 2：** 接下来只要稍微旋转一下。

我们先构造边长都是整数的多边形。

对于偶数的情况，我们只需构造一个阶梯的形状。

对于奇数的情况，我们只需把偶数情况的一条边变成两条边。将那条边作为直角三角形的斜边就行。

如构造的 $(0,0)\to (25,0)$ 可以变成 $(0,0)\to (9,-12)\to(25, 0)$ 。

接下来我们旋转图形即可。

也就只需要找到一个向量和法向量，再把我们做出来的所有点求出在新方向上的投影。注意投影可能出现有理数，此时你只要把所有点的横坐标和纵坐标乘以一个相同的数即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    pts = []
    
    if n % 2:
        pts.append((0, 0))
        
        x, y = 0, 0
        for i in range(n // 2 - 1):
            y += 25
            pts.append((x, y))
            x += 25
            pts.append((x, y))
        
        x = fmax(x, 25)
        pts.append((x, 0))
        pts.append((x // 25 * 9, -x // 25 * 12))
    
    else:
        pts.append((0, 0))
        
        x, y = 0, 0
        for i in range(n // 2 - 1):
            y += 25
            pts.append((x, y))
            x += 25
            pts.append((x, y))
        
        pts.append((x, 0))
    
    dx, dy = 5, 12
    
    for x, y in pts:
        print(x * dx + y * dy, x * (-dy) + y * dx)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<pair<int, int>> pts;

	if (n & 1) {
		pts.emplace_back(0, 0);

		int x = 0, y = 0;

		for (int i = 0; i < n / 2 - 1; i ++) {
			y += 25;
			pts.emplace_back(x, y);
			x += 25;
			pts.emplace_back(x, y);
		}

		x = max(x, 25);
		pts.emplace_back(x, 0);
		pts.emplace_back(x / 25 * 9, -x / 25 * 12);
	}
	else {
		pts.emplace_back(0, 0);

		int x = 0, y = 0;

		for (int i = 0; i < n / 2 - 1; i ++) {
			y += 25;
			pts.emplace_back(x, y);
			x += 25;
			pts.emplace_back(x, y);
		}

		pts.emplace_back(x, 0);		
	}

	int dx = 5, dy = 12;

	for (auto &[x, y]: pts)
		cout << x * dx + y * dy << ' ' << x * (-dy) + y * dx << '\n';

	return 0;
}
```