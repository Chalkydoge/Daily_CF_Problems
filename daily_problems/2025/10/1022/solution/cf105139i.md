**提示 1：** 新增点维护直径是相对容易的，怎么做？

**提示 2：** 如何把刚才的问题转化为新增点。

也可以用线段树分治来做，但是复杂度高了。

修改颜色的总点数是 $\mathcal{O}(n)$ 的，因为变为黑色之后就不会再变回来。所以我们对于每次操作，可以找到该操作影响的所有点来刻画这次操作。

具体而言，我们需要从点 $u,v$ ，往上走到 $lca$ 。对于其中一个点，如果还没到 $lca$ ，如果当前点已经是黑色，就跳到黑色连通块中深度最小的点，并往上走一步，此时这一步一定是白色结点；否则，将当前白色结点染黑，并重新维护这个白色结点所在的黑色连通块。

这样我们就知道每个结点时什么时候变成黑色的了。

有个经典问题就是，新增一个点，看当前图的最大直径。这就解决了所有黑色连通块的问题。

怎么做呢？我们维护每个连通块当前的直径以及直径的端点。

那么新增一个点时，可能有一条边使得两个连通块连到了一起，此时直径如何变化呢？

一种情况是不用这条边，此时直径仍然在原先的连通块内部。

另一种情况是这条边在新的直径上，此时我们要找到两侧的连通块内距离这条边最远的点，而这种点一定有一个在直径上（否则可以把直径的一个端点换成它进而使得直径长度严格增加，可以画一个 $u\to LCA\to v$ 的图看一下，如果有一个深度更大的点直径如何改变），因此枚举两个连通块当前直径的端点选择哪一个，枚举 $2\times 2$ 的情况即可判断直径是否需要更新。

那白色的连通块内的直径怎么办呢？白色的点相当于是不断删除的，此时我们从后往前考虑，就也是不断加点的过程了。因此离线查询，逆向遍历后维护白色连通块及对应直径即可。

时间复杂度为 $\mathcal{O}(n\log n+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, q = MII()
        path = [[] for _ in range(n + 1)]
        
        for _ in range(n - 1):
            u, v = MII()
            path[u].append(v)
            path[v].append(u)
        
        parent = [0] * (n + 1)
        depth = [0] * (n + 1)
        depth[0] = -1
        
        que = [1]
        for u in que:
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    depth[v] = depth[u] + 1
                    que.append(v)
        
        stk = [1]
        ids = [0] * (n + 1)
        dfs_order = []
        
        while stk:
            u = stk.pop()
            dfs_order.append(u)
            if ids[u] == len(path[u]):
                continue
            
            if path[u][ids[u]] == parent[u]:
                ids[u] += 1
            
            if ids[u] == len(path[u]):
                continue
            stk.append(u)
            stk.append(path[u][ids[u]])
            ids[u] += 1
        
        ls = [3 * n] * (n + 1)
        rs = [0] * (n + 1)
    
        for i in range(len(dfs_order)):
            u = dfs_order[i]
            ls[u] = fmin(ls[u], i)
            rs[u] = fmax(rs[u], i)
            dfs_order[i] += depth[dfs_order[i]] * (n + 1)
        
        st = SparseTable(dfs_order, fmin)
    
        def lca(u, v):
            if ls[u] > ls[v]:
                u, v = v, u
            return st.query(ls[u], ls[v]) % (n + 1)
    
        def dis(u, v):
            return depth[u] + depth[v] - 2 * depth[lca(u, v)]
        
        uf = UnionFind(n + 1)
        top_notes = list(range(n + 1))
    
        tmstamp = [q] * (n + 1)
        
        for tid in range(q):
            u, v = MII()
            l = lca(u, v)
            
            while True:
                u = top_notes[uf.find(u)]
                if depth[u] < depth[l]: break
                tmstamp[u] = tid
                ntop = top_notes[uf.find(parent[u])]
                uf.merge(u, parent[u])
                top_notes[uf.find(u)] = ntop
            
            while True:
                v = top_notes[uf.find(v)]
                if depth[v] < depth[l]: break
                tmstamp[v] = tid
                ntop = top_notes[uf.find(parent[v])]
                uf.merge(v, parent[v])
                top_notes[uf.find(v)] = ntop
        
        tmp = [[] for _ in range(q + 1)]
        for i in range(n + 1):
            tmp[tmstamp[i]].append(i)
        
        ans = [0] * q
        
        us = list(range(n + 1))
        vs = list(range(n + 1))
        ds = [0] * (n + 1)
        
        uf.init()
        
        col = [0] * (n + 1)
        
        cur = 0
        for tid in range(q):
            for u in tmp[tid]:
                col[u] = 1
                for v in path[u]:
                    if col[v] == 1:
                        fu = uf.find(u)
                        fv = uf.find(v)
                        
                        nu, nv, nd = us[fu], vs[fu], ds[fu]
                        if ds[fv] > ds[fu]:
                            nu, nv, nd = us[fv], vs[fv], ds[fv]
                        
                        xu, xv = us[fu], vs[fu]
                        yu, yv = us[fv], vs[fv]
                        
                        for x in [xu, xv]:
                            for y in [yu, yv]:
                                d = dis(x, y)
                                if d > nd:
                                    nu = x
                                    nv = y
                                    nd = d
                        
                        uf.merge(u, v)
                        fu = uf.find(u)
                        
                        us[fu] = nu
                        vs[fu] = nv
                        ds[fu] = nd
                        
                        cur = fmax(cur, nd)
            
            ans[tid] = cur
        
        us = list(range(n + 1))
        vs = list(range(n + 1))
        ds = [0] * (n + 1)
        
        uf.init()
        
        col = [0] * (n + 1)
        
        cur = 0
        for tid in range(q - 1, -1, -1):
            for u in tmp[tid + 1]:
                col[u] = 1
                for v in path[u]:
                    if col[v] == 1:
                        fu = uf.find(u)
                        fv = uf.find(v)
                        
                        nu, nv, nd = us[fu], vs[fu], ds[fu]
                        if ds[fv] > ds[fu]:
                            nu, nv, nd = us[fv], vs[fv], ds[fv]
                        
                        xu, xv = us[fu], vs[fu]
                        yu, yv = us[fv], vs[fv]
                        
                        for x in [xu, xv]:
                            for y in [yu, yv]:
                                d = dis(x, y)
                                if d > nd:
                                    nu = x
                                    nv = y
                                    nd = d
                        
                        uf.merge(u, v)
                        fu = uf.find(u)
                        
                        us[fu] = nu
                        vs[fu] = nv
                        ds[fu] = nd
                        
                        cur = fmax(cur, nd)
            ans[tid] = fmax(ans[tid], cur)
    
        outs.append('\n'.join(str(x + 1) for x in ans))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		vector<vector<int>> path(n);

		for (int i = 0; i < n - 1; i ++) {
			int u, v;
			cin >> u >> v;
			u --, v --;
			path[u].emplace_back(v);
			path[v].emplace_back(u);
		}

		vector<int> parent(n + 1, 0), depth(n + 1, 0), ls(n, 0);
		depth[n] = -1;

		vector<long long> dfs_order;

		auto dfs = [&] (auto &self, int u, int p) -> void {
			parent[u] = p;
			ls[u] = dfs_order.size();
			dfs_order.emplace_back(u);

			for (auto &v: path[u]) {
				if (v != p) {
					depth[v] = depth[u] + 1;
					self(self, v, u);
					dfs_order.emplace_back(u);
				}
			}
		};

		dfs(dfs, 0, n);

		for (auto &x: dfs_order)
			x += 1ll * depth[x] * n;

		ST<long long, op> st(dfs_order);

		auto lca = [&] (int u, int v) -> int {
			if (ls[u] > ls[v]) swap(u, v);
			return st.prod(ls[u], ls[v] + 1) % n;
		};

		auto dis = [&] (int u, int v) -> int {
			return depth[u] + depth[v] - depth[lca(u, v)] * 2;
		};

		vector<int> tmstamps(n, q), top(n + 1);
		atcoder::dsu uf(n + 1);

		iota(top.begin(), top.end(), 0);

		for (int tid = 0; tid < q; tid ++) {
			int u, v;
			cin >> u >> v;
			u --, v --;
			auto l = lca(u, v);

			while (true) {
				u = top[uf.leader(u)];
				if (depth[u] < depth[l]) break;
				tmstamps[u] = tid;
				int ntop = top[uf.leader(parent[u])];
				uf.merge(u, parent[u]);
				top[uf.leader(u)] = ntop;
			}

			while (true) {
				v = top[uf.leader(v)];
				if (depth[v] < depth[l]) break;
				tmstamps[v] = tid;
				int ntop = top[uf.leader(parent[v])];
				uf.merge(v, parent[v]);
				top[uf.leader(v)] = ntop;
			}
		}

		vector<vector<int>> tmp(q + 1);
		for (int i = 0; i < n; i ++)
			tmp[tmstamps[i]].emplace_back(i);
		
		vector<int> ans(q, 0);

		vector<int> us(n + 1), vs(n + 1), ds(n + 1), col(n + 1, 0);
		int cur;
		
		iota(us.begin(), us.end(), 0);
		iota(vs.begin(), vs.end(), 0);
		fill(ds.begin(), ds.end(), 0);
		fill(col.begin(), col.end(), 0);
		uf.init();
		cur = 0;

		for (int tid = 0; tid < q; tid ++) {
			for (auto &u: tmp[tid]) {
				col[u] = 1;
				for (auto &v: path[u]) {
					if (col[v] == 1) {
						int fu = uf.leader(u), fv = uf.leader(v);

						int nu = us[fu], nv = vs[fu], nd = ds[fu];
						if (ds[fv] > ds[fu])
							nu = us[fv], nv = vs[fv], nd = ds[fv];
						
						for (auto &x: {us[fu], vs[fu]}) {
							for (auto &y: {us[fv], vs[fv]}) {
								int d = dis(x, y);
								if (d > nd)
									nu = x, nv = y, nd = d;
							}
						}

						uf.merge(u, v);
						fu = uf.leader(u);

						us[fu] = nu, vs[fu] = nv, ds[fu] = nd;
						cur = max(cur, nd);
					}
				}
			}
			ans[tid] = cur;
		}
			
		iota(us.begin(), us.end(), 0);
		iota(vs.begin(), vs.end(), 0);
		fill(ds.begin(), ds.end(), 0);
		fill(col.begin(), col.end(), 0);
		uf.init();
		cur = 0;

		for (int tid = q - 1; tid >= 0; tid --) {
			for (auto &u: tmp[tid + 1]) {
				col[u] = 1;
				for (auto &v: path[u]) {
					if (col[v] == 1) {
						int fu = uf.leader(u), fv = uf.leader(v);

						int nu = us[fu], nv = vs[fu], nd = ds[fu];
						if (ds[fv] > ds[fu])
							nu = us[fv], nv = vs[fv], nd = ds[fv];
						
						for (auto &x: {us[fu], vs[fu]}) {
							for (auto &y: {us[fv], vs[fv]}) {
								int d = dis(x, y);
								if (d > nd)
									nu = x, nv = y, nd = d;
							}
						}

						uf.merge(u, v);
						fu = uf.leader(u);

						us[fu] = nu, vs[fu] = nv, ds[fu] = nd;
						cur = max(cur, nd);
					}
				}
			}
			ans[tid] = max(ans[tid], cur);
		}

		for (auto &x: ans) cout << x + 1 << '\n';
	}

	return 0;
}
```